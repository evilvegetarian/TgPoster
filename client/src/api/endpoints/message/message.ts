/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * TgPoster.API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateMessageResponse,
  GetApiV1MessageParams,
  MessageResponse,
  PostApiV1MessageBatchFromFilesBody,
  PostApiV1MessageBatchFromFilesParams,
  PostApiV1MessageBody,
  PostApiV1MessageParams,
  ProblemDetails
} from '../tgPosterAPI.schemas';

import { customInstance } from '../../axios-instance';




/**
 * @summary –°–æ–∑–¥–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ —Ñ–∞–π–ª–æ–≤, –æ–¥–∏–Ω —Ñ–∞–π–ª = –æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.
 */
export const postApiV1MessageBatchFromFiles = (
    postApiV1MessageBatchFromFilesBody: PostApiV1MessageBatchFromFilesBody,
    params: PostApiV1MessageBatchFromFilesParams,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
postApiV1MessageBatchFromFilesBody.Files.forEach(value => formData.append(`Files`, value));

      return customInstance<void>(
      {url: `/api/v1/message/batch-from-files`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData,
        params, signal
    },
      );
    }
  


export const getPostApiV1MessageBatchFromFilesMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1MessageBatchFromFiles>>, TError,{data: PostApiV1MessageBatchFromFilesBody;params: PostApiV1MessageBatchFromFilesParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiV1MessageBatchFromFiles>>, TError,{data: PostApiV1MessageBatchFromFilesBody;params: PostApiV1MessageBatchFromFilesParams}, TContext> => {

const mutationKey = ['postApiV1MessageBatchFromFiles'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiV1MessageBatchFromFiles>>, {data: PostApiV1MessageBatchFromFilesBody;params: PostApiV1MessageBatchFromFilesParams}> = (props) => {
          const {data,params} = props ?? {};

          return  postApiV1MessageBatchFromFiles(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiV1MessageBatchFromFilesMutationResult = NonNullable<Awaited<ReturnType<typeof postApiV1MessageBatchFromFiles>>>
    export type PostApiV1MessageBatchFromFilesMutationBody = PostApiV1MessageBatchFromFilesBody
    export type PostApiV1MessageBatchFromFilesMutationError = ProblemDetails

    /**
 * @summary –°–æ–∑–¥–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ —Ñ–∞–π–ª–æ–≤, –æ–¥–∏–Ω —Ñ–∞–π–ª = –æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.
 */
export const usePostApiV1MessageBatchFromFiles = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1MessageBatchFromFiles>>, TError,{data: PostApiV1MessageBatchFromFilesBody;params: PostApiV1MessageBatchFromFilesParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiV1MessageBatchFromFiles>>,
        TError,
        {data: PostApiV1MessageBatchFromFilesBody;params: PostApiV1MessageBatchFromFilesParams},
        TContext
      > => {

      const mutationOptions = getPostApiV1MessageBatchFromFilesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
 */
export const getApiV1Message = (
    params: GetApiV1MessageParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse[]>(
      {url: `/api/v1/message`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetApiV1MessageQueryKey = (params: GetApiV1MessageParams,) => {
    return [`/api/v1/message`, ...(params ? [params]: [])] as const;
    }

    
export const getGetApiV1MessageQueryOptions = <TData = Awaited<ReturnType<typeof getApiV1Message>>, TError = ProblemDetails>(params: GetApiV1MessageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Message>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiV1MessageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiV1Message>>> = ({ signal }) => getApiV1Message(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiV1Message>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiV1MessageQueryResult = NonNullable<Awaited<ReturnType<typeof getApiV1Message>>>
export type GetApiV1MessageQueryError = ProblemDetails


export function useGetApiV1Message<TData = Awaited<ReturnType<typeof getApiV1Message>>, TError = ProblemDetails>(
 params: GetApiV1MessageParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Message>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1Message>>,
          TError,
          Awaited<ReturnType<typeof getApiV1Message>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1Message<TData = Awaited<ReturnType<typeof getApiV1Message>>, TError = ProblemDetails>(
 params: GetApiV1MessageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Message>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1Message>>,
          TError,
          Awaited<ReturnType<typeof getApiV1Message>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1Message<TData = Awaited<ReturnType<typeof getApiV1Message>>, TError = ProblemDetails>(
 params: GetApiV1MessageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Message>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
 */

export function useGetApiV1Message<TData = Awaited<ReturnType<typeof getApiV1Message>>, TError = ProblemDetails>(
 params: GetApiV1MessageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Message>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiV1MessageQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary –°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
 */
export const postApiV1Message = (
    postApiV1MessageBody: PostApiV1MessageBody,
    params: PostApiV1MessageParams,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
if(postApiV1MessageBody.Files !== undefined) {
 postApiV1MessageBody.Files.forEach(value => formData.append(`Files`, value));
 }

      return customInstance<CreateMessageResponse>(
      {url: `/api/v1/message`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData,
        params, signal
    },
      );
    }
  


export const getPostApiV1MessageMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1Message>>, TError,{data: PostApiV1MessageBody;params: PostApiV1MessageParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiV1Message>>, TError,{data: PostApiV1MessageBody;params: PostApiV1MessageParams}, TContext> => {

const mutationKey = ['postApiV1Message'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiV1Message>>, {data: PostApiV1MessageBody;params: PostApiV1MessageParams}> = (props) => {
          const {data,params} = props ?? {};

          return  postApiV1Message(data,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiV1MessageMutationResult = NonNullable<Awaited<ReturnType<typeof postApiV1Message>>>
    export type PostApiV1MessageMutationBody = PostApiV1MessageBody
    export type PostApiV1MessageMutationError = ProblemDetails

    /**
 * @summary –°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
 */
export const usePostApiV1Message = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1Message>>, TError,{data: PostApiV1MessageBody;params: PostApiV1MessageParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiV1Message>>,
        TError,
        {data: PostApiV1MessageBody;params: PostApiV1MessageParams},
        TContext
      > => {

      const mutationOptions = getPostApiV1MessageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ Id
 */
export const getApiV1MessageId = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/api/v1/message/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetApiV1MessageIdQueryKey = (id: string,) => {
    return [`/api/v1/message/${id}`] as const;
    }

    
export const getGetApiV1MessageIdQueryOptions = <TData = Awaited<ReturnType<typeof getApiV1MessageId>>, TError = ProblemDetails>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageId>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiV1MessageIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiV1MessageId>>> = ({ signal }) => getApiV1MessageId(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiV1MessageIdQueryResult = NonNullable<Awaited<ReturnType<typeof getApiV1MessageId>>>
export type GetApiV1MessageIdQueryError = ProblemDetails


export function useGetApiV1MessageId<TData = Awaited<ReturnType<typeof getApiV1MessageId>>, TError = ProblemDetails>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1MessageId>>,
          TError,
          Awaited<ReturnType<typeof getApiV1MessageId>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1MessageId<TData = Awaited<ReturnType<typeof getApiV1MessageId>>, TError = ProblemDetails>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1MessageId>>,
          TError,
          Awaited<ReturnType<typeof getApiV1MessageId>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1MessageId<TData = Awaited<ReturnType<typeof getApiV1MessageId>>, TError = ProblemDetails>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageId>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ Id
 */

export function useGetApiV1MessageId<TData = Awaited<ReturnType<typeof getApiV1MessageId>>, TError = ProblemDetails>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageId>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiV1MessageIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



