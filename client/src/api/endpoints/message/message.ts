/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * TgPoster.API
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ApproveMessagesRequest,
  CreateMessageResponse,
  GetApiV1MessageParams,
  GetTimeResponse,
  MessageResponse,
  MessageResponsePagedResponse,
  PostApiV1MessageBatchFromFilesBody,
  PostApiV1MessageBody,
  ProblemDetails,
  PutApiV1MessageIdBody
} from '../tgPosterAPI.schemas';

import { customInstance } from '../../axios-instance';




/**
 * @summary –°–æ–∑–¥–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ —Ñ–∞–π–ª–æ–≤, –æ–¥–∏–Ω —Ñ–∞–π–ª = –æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.
 */
export const postApiV1MessageBatchFromFiles = (
    postApiV1MessageBatchFromFilesBody: PostApiV1MessageBatchFromFilesBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`ScheduleId`, postApiV1MessageBatchFromFilesBody.ScheduleId)
postApiV1MessageBatchFromFilesBody.Files.forEach(value => formData.append(`Files`, value));

      return customInstance<void>(
      {url: `/api/v1/message/batch-from-files`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getPostApiV1MessageBatchFromFilesMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1MessageBatchFromFiles>>, TError,{data: PostApiV1MessageBatchFromFilesBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiV1MessageBatchFromFiles>>, TError,{data: PostApiV1MessageBatchFromFilesBody}, TContext> => {

const mutationKey = ['postApiV1MessageBatchFromFiles'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiV1MessageBatchFromFiles>>, {data: PostApiV1MessageBatchFromFilesBody}> = (props) => {
          const {data} = props ?? {};

          return  postApiV1MessageBatchFromFiles(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiV1MessageBatchFromFilesMutationResult = NonNullable<Awaited<ReturnType<typeof postApiV1MessageBatchFromFiles>>>
    export type PostApiV1MessageBatchFromFilesMutationBody = PostApiV1MessageBatchFromFilesBody
    export type PostApiV1MessageBatchFromFilesMutationError = ProblemDetails

    /**
 * @summary –°–æ–∑–¥–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ —Ñ–∞–π–ª–æ–≤, –æ–¥–∏–Ω —Ñ–∞–π–ª = –æ–¥–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ.
 */
export const usePostApiV1MessageBatchFromFiles = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1MessageBatchFromFiles>>, TError,{data: PostApiV1MessageBatchFromFilesBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiV1MessageBatchFromFiles>>,
        TError,
        {data: PostApiV1MessageBatchFromFilesBody},
        TContext
      > => {

      const mutationOptions = getPostApiV1MessageBatchFromFilesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π c –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π.
 */
export const getApiV1Message = (
    params: GetApiV1MessageParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponsePagedResponse>(
      {url: `/api/v1/message`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetApiV1MessageQueryKey = (params: GetApiV1MessageParams,) => {
    return [`/api/v1/message`, ...(params ? [params]: [])] as const;
    }

    
export const getGetApiV1MessageQueryOptions = <TData = Awaited<ReturnType<typeof getApiV1Message>>, TError = ProblemDetails>(params: GetApiV1MessageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Message>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiV1MessageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiV1Message>>> = ({ signal }) => getApiV1Message(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiV1Message>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiV1MessageQueryResult = NonNullable<Awaited<ReturnType<typeof getApiV1Message>>>
export type GetApiV1MessageQueryError = ProblemDetails


export function useGetApiV1Message<TData = Awaited<ReturnType<typeof getApiV1Message>>, TError = ProblemDetails>(
 params: GetApiV1MessageParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Message>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1Message>>,
          TError,
          Awaited<ReturnType<typeof getApiV1Message>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1Message<TData = Awaited<ReturnType<typeof getApiV1Message>>, TError = ProblemDetails>(
 params: GetApiV1MessageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Message>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1Message>>,
          TError,
          Awaited<ReturnType<typeof getApiV1Message>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1Message<TData = Awaited<ReturnType<typeof getApiV1Message>>, TError = ProblemDetails>(
 params: GetApiV1MessageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Message>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π c –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π.
 */

export function useGetApiV1Message<TData = Awaited<ReturnType<typeof getApiV1Message>>, TError = ProblemDetails>(
 params: GetApiV1MessageParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1Message>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiV1MessageQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary –°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
 */
export const postApiV1Message = (
    postApiV1MessageBody: PostApiV1MessageBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`ScheduleId`, postApiV1MessageBody.ScheduleId)
formData.append(`TimePosting`, postApiV1MessageBody.TimePosting)
if(postApiV1MessageBody.TextMessage !== undefined) {
 formData.append(`TextMessage`, postApiV1MessageBody.TextMessage)
 }
if(postApiV1MessageBody.Files !== undefined) {
 postApiV1MessageBody.Files.forEach(value => formData.append(`Files`, value));
 }

      return customInstance<CreateMessageResponse>(
      {url: `/api/v1/message`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getPostApiV1MessageMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1Message>>, TError,{data: PostApiV1MessageBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiV1Message>>, TError,{data: PostApiV1MessageBody}, TContext> => {

const mutationKey = ['postApiV1Message'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiV1Message>>, {data: PostApiV1MessageBody}> = (props) => {
          const {data} = props ?? {};

          return  postApiV1Message(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiV1MessageMutationResult = NonNullable<Awaited<ReturnType<typeof postApiV1Message>>>
    export type PostApiV1MessageMutationBody = PostApiV1MessageBody
    export type PostApiV1MessageMutationError = ProblemDetails

    /**
 * @summary –°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
 */
export const usePostApiV1Message = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiV1Message>>, TError,{data: PostApiV1MessageBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiV1Message>>,
        TError,
        {data: PostApiV1MessageBody},
        TContext
      > => {

      const mutationOptions = getPostApiV1MessageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π
 */
export const patchApiV1Message = (
    approveMessagesRequest: ApproveMessagesRequest,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/message`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: approveMessagesRequest
    },
      );
    }
  


export const getPatchApiV1MessageMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiV1Message>>, TError,{data: ApproveMessagesRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patchApiV1Message>>, TError,{data: ApproveMessagesRequest}, TContext> => {

const mutationKey = ['patchApiV1Message'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchApiV1Message>>, {data: ApproveMessagesRequest}> = (props) => {
          const {data} = props ?? {};

          return  patchApiV1Message(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchApiV1MessageMutationResult = NonNullable<Awaited<ReturnType<typeof patchApiV1Message>>>
    export type PatchApiV1MessageMutationBody = ApproveMessagesRequest
    export type PatchApiV1MessageMutationError = ProblemDetails

    /**
 * @summary –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π
 */
export const usePatchApiV1Message = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiV1Message>>, TError,{data: ApproveMessagesRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchApiV1Message>>,
        TError,
        {data: ApproveMessagesRequest},
        TContext
      > => {

      const mutationOptions = getPatchApiV1MessageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary –£–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è
 */
export const deleteApiV1Message = (
    deleteApiV1MessageBody: string[],
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/message`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: deleteApiV1MessageBody
    },
      );
    }
  


export const getDeleteApiV1MessageMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1Message>>, TError,{data: string[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1Message>>, TError,{data: string[]}, TContext> => {

const mutationKey = ['deleteApiV1Message'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiV1Message>>, {data: string[]}> = (props) => {
          const {data} = props ?? {};

          return  deleteApiV1Message(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiV1MessageMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiV1Message>>>
    export type DeleteApiV1MessageMutationBody = string[]
    export type DeleteApiV1MessageMutationError = ProblemDetails

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏—è
 */
export const useDeleteApiV1Message = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1Message>>, TError,{data: string[]}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiV1Message>>,
        TError,
        {data: string[]},
        TContext
      > => {

      const mutationOptions = getDeleteApiV1MessageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ Id
 */
export const getApiV1MessageId = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<MessageResponse>(
      {url: `/api/v1/message/${id}`, method: 'GET', signal
    },
      );
    }
  

export const getGetApiV1MessageIdQueryKey = (id: string,) => {
    return [`/api/v1/message/${id}`] as const;
    }

    
export const getGetApiV1MessageIdQueryOptions = <TData = Awaited<ReturnType<typeof getApiV1MessageId>>, TError = ProblemDetails>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageId>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiV1MessageIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiV1MessageId>>> = ({ signal }) => getApiV1MessageId(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiV1MessageIdQueryResult = NonNullable<Awaited<ReturnType<typeof getApiV1MessageId>>>
export type GetApiV1MessageIdQueryError = ProblemDetails


export function useGetApiV1MessageId<TData = Awaited<ReturnType<typeof getApiV1MessageId>>, TError = ProblemDetails>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1MessageId>>,
          TError,
          Awaited<ReturnType<typeof getApiV1MessageId>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1MessageId<TData = Awaited<ReturnType<typeof getApiV1MessageId>>, TError = ProblemDetails>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1MessageId>>,
          TError,
          Awaited<ReturnType<typeof getApiV1MessageId>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1MessageId<TData = Awaited<ReturnType<typeof getApiV1MessageId>>, TError = ProblemDetails>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageId>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ Id
 */

export function useGetApiV1MessageId<TData = Awaited<ReturnType<typeof getApiV1MessageId>>, TError = ProblemDetails>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageId>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiV1MessageIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary –ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è
 */
export const putApiV1MessageId = (
    id: string,
    putApiV1MessageIdBody: PutApiV1MessageIdBody,
 ) => {
      
      const formData = new FormData();
formData.append(`ScheduleId`, putApiV1MessageIdBody.ScheduleId)
formData.append(`TimePosting`, putApiV1MessageIdBody.TimePosting)
if(putApiV1MessageIdBody.TextMessage !== undefined) {
 formData.append(`TextMessage`, putApiV1MessageIdBody.TextMessage)
 }
if(putApiV1MessageIdBody.OldFiles !== undefined) {
 putApiV1MessageIdBody.OldFiles.forEach(value => formData.append(`OldFiles`, value));
 }
if(putApiV1MessageIdBody.NewFiles !== undefined) {
 putApiV1MessageIdBody.NewFiles.forEach(value => formData.append(`NewFiles`, value));
 }

      return customInstance<void>(
      {url: `/api/v1/message/${id}`, method: 'PUT',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData
    },
      );
    }
  


export const getPutApiV1MessageIdMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiV1MessageId>>, TError,{id: string;data: PutApiV1MessageIdBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof putApiV1MessageId>>, TError,{id: string;data: PutApiV1MessageIdBody}, TContext> => {

const mutationKey = ['putApiV1MessageId'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putApiV1MessageId>>, {id: string;data: PutApiV1MessageIdBody}> = (props) => {
          const {id,data} = props ?? {};

          return  putApiV1MessageId(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutApiV1MessageIdMutationResult = NonNullable<Awaited<ReturnType<typeof putApiV1MessageId>>>
    export type PutApiV1MessageIdMutationBody = PutApiV1MessageIdBody
    export type PutApiV1MessageIdMutationError = ProblemDetails

    /**
 * @summary –ò–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è
 */
export const usePutApiV1MessageId = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putApiV1MessageId>>, TError,{id: string;data: PutApiV1MessageIdBody}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof putApiV1MessageId>>,
        TError,
        {id: string;data: PutApiV1MessageIdBody},
        TContext
      > => {

      const mutationOptions = getPutApiV1MessageIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary –£–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª —Å–æ–æ–±—â–µ–Ω–∏—è
 */
export const deleteApiV1MessageIdFilesFileId = (
    id: string,
    fileId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/message/${id}/files/${fileId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteApiV1MessageIdFilesFileIdMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1MessageIdFilesFileId>>, TError,{id: string;fileId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1MessageIdFilesFileId>>, TError,{id: string;fileId: string}, TContext> => {

const mutationKey = ['deleteApiV1MessageIdFilesFileId'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteApiV1MessageIdFilesFileId>>, {id: string;fileId: string}> = (props) => {
          const {id,fileId} = props ?? {};

          return  deleteApiV1MessageIdFilesFileId(id,fileId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteApiV1MessageIdFilesFileIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteApiV1MessageIdFilesFileId>>>
    
    export type DeleteApiV1MessageIdFilesFileIdMutationError = ProblemDetails

    /**
 * @summary –£–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª —Å–æ–æ–±—â–µ–Ω–∏—è
 */
export const useDeleteApiV1MessageIdFilesFileId = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteApiV1MessageIdFilesFileId>>, TError,{id: string;fileId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteApiV1MessageIdFilesFileId>>,
        TError,
        {id: string;fileId: string},
        TContext
      > => {

      const mutationOptions = getDeleteApiV1MessageIdFilesFileIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª—ã —Å–æ–æ–±—â–µ–Ω–∏—è
 */
export const patchApiV1MessageIdFile = (
    id: string,
    patchApiV1MessageIdFileBody: Blob[],
 ) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/message/${id}/file`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: patchApiV1MessageIdFileBody
    },
      );
    }
  


export const getPatchApiV1MessageIdFileMutationOptions = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiV1MessageIdFile>>, TError,{id: string;data: Blob[]}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof patchApiV1MessageIdFile>>, TError,{id: string;data: Blob[]}, TContext> => {

const mutationKey = ['patchApiV1MessageIdFile'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof patchApiV1MessageIdFile>>, {id: string;data: Blob[]}> = (props) => {
          const {id,data} = props ?? {};

          return  patchApiV1MessageIdFile(id,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PatchApiV1MessageIdFileMutationResult = NonNullable<Awaited<ReturnType<typeof patchApiV1MessageIdFile>>>
    export type PatchApiV1MessageIdFileMutationBody = Blob[]
    export type PatchApiV1MessageIdFileMutationError = ProblemDetails

    /**
 * @summary –ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª—ã —Å–æ–æ–±—â–µ–Ω–∏—è
 */
export const usePatchApiV1MessageIdFile = <TError = ProblemDetails,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof patchApiV1MessageIdFile>>, TError,{id: string;data: Blob[]}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof patchApiV1MessageIdFile>>,
        TError,
        {id: string;data: Blob[]},
        TContext
      > => {

      const mutationOptions = getPatchApiV1MessageIdFileMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –±–ª–∏–∂–∞–π—à–µ–µ –ø–æ–¥—Ö–æ–¥—è—â–µ–µ –≤—Ä–µ–º—è –ø–æ—Å—Ç–∏–Ω–≥–∞
 */
export const getApiV1MessageScheduleIdTime = (
    scheduleId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<GetTimeResponse>(
      {url: `/api/v1/message/${scheduleId}/time`, method: 'GET', signal
    },
      );
    }
  

export const getGetApiV1MessageScheduleIdTimeQueryKey = (scheduleId: string,) => {
    return [`/api/v1/message/${scheduleId}/time`] as const;
    }

    
export const getGetApiV1MessageScheduleIdTimeQueryOptions = <TData = Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>, TError = ProblemDetails>(scheduleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiV1MessageScheduleIdTimeQueryKey(scheduleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>> = ({ signal }) => getApiV1MessageScheduleIdTime(scheduleId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(scheduleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiV1MessageScheduleIdTimeQueryResult = NonNullable<Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>>
export type GetApiV1MessageScheduleIdTimeQueryError = ProblemDetails


export function useGetApiV1MessageScheduleIdTime<TData = Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>, TError = ProblemDetails>(
 scheduleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>,
          TError,
          Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1MessageScheduleIdTime<TData = Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>, TError = ProblemDetails>(
 scheduleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>,
          TError,
          Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiV1MessageScheduleIdTime<TData = Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>, TError = ProblemDetails>(
 scheduleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary –ü–æ–ª—É—á–∏—Ç—å –±–ª–∏–∂–∞–π—à–µ–µ –ø–æ–¥—Ö–æ–¥—è—â–µ–µ –≤—Ä–µ–º—è –ø–æ—Å—Ç–∏–Ω–≥–∞
 */

export function useGetApiV1MessageScheduleIdTime<TData = Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>, TError = ProblemDetails>(
 scheduleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiV1MessageScheduleIdTime>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiV1MessageScheduleIdTimeQueryOptions(scheduleId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



